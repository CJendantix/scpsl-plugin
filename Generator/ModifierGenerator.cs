using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Collections.Generic;

[Generator]
public sealed class ModifierGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates = context.SyntaxProvider.CreateSyntaxProvider(
            (n, _) => n is ClassDeclarationSyntax c && c.AttributeLists.Count > 0,
            (ctx, _) => (ClassDeclarationSyntax)ctx.Node);

        var combined = context.CompilationProvider.Combine(candidates.Collect());
        context.RegisterSourceOutput(combined, Generate);
    }

    static void Generate(SourceProductionContext context,
        (Compilation, ImmutableArray<ClassDeclarationSyntax>) data)
    {
        Compilation compilation = data.Item1;
        ImmutableArray<ClassDeclarationSyntax> classes = data.Item2;

        // Find types by searching all types in compilation instead of by metadata name
        INamedTypeSymbol autoAttr = FindTypeByName(compilation, "AutoModifierAttribute");
        INamedTypeSymbol baseType = FindTypeByName(compilation, "Modifier");
        INamedTypeSymbol cfgAttr = FindTypeByName(compilation, "ConfigurableAttribute");

        if (autoAttr == null || baseType == null || cfgAttr == null)
            return;

        const string GeneratedNamespace = "Generated";

        // Loader
        StringBuilder loader = new StringBuilder();
        loader.AppendLine("// <auto-generated/>");
        loader.AppendLine($"namespace {GeneratedNamespace}");
        loader.AppendLine("{");
        loader.AppendLine("    /// <summary>Automatically loads all modifiers and initializes their static instances.</summary>");
        loader.AppendLine("    public static class GeneratedModifierLoader");
        loader.AppendLine("    {");
        loader.AppendLine("        public static void LoadAllModifiers()");
        loader.AppendLine("        {");

        // Configuration root
        StringBuilder rootCfg = new StringBuilder();
        rootCfg.AppendLine("// <auto-generated/>");
        rootCfg.AppendLine($"namespace {GeneratedNamespace}");
        rootCfg.AppendLine("{");
        rootCfg.AppendLine("    /// <summary>Partial Configuration class generated for all modifiers.</summary>");
        rootCfg.AppendLine("    public sealed partial class Configuration");
        rootCfg.AppendLine("    {");

        List<string> applyAllCalls = new List<string>();
        List<string> pullAllCalls = new List<string>();

        foreach (ClassDeclarationSyntax cls in classes)
        {
            SemanticModel model = compilation.GetSemanticModel(cls.SyntaxTree);
            if (!(model.GetDeclaredSymbol(cls) is INamedTypeSymbol sym) || sym.IsAbstract)
                continue;

            AttributeData a = sym.GetAttributes()
                .FirstOrDefault(x => SymbolEqualityComparer.Default.Equals(x.AttributeClass, autoAttr));
            if (a == null)
                continue;

            // Enforce that [AutoModifier] classes must inherit from Modifier
            if (!InheritsFrom(sym, baseType))
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "MODGEN001",
                        "AutoModifier must inherit from Modifier",
                        "Class '{0}' has [AutoModifier] attribute but does not inherit from Modifier",
                        "Modifiers",
                        DiagnosticSeverity.Error,
                        true),
                    sym.Locations[0],
                    sym.Name));
                continue;
            }

            // Get namespace and type information
            string namespaceName = GetNamespace(sym);
            string fullTypeName = sym.ToDisplayString();
            string className = sym.Name;

            // Generate static Instance property for this modifier
            StringBuilder instanceGen = new StringBuilder();
            instanceGen.AppendLine("// <auto-generated/>");
            
            if (!string.IsNullOrEmpty(namespaceName))
            {
                instanceGen.AppendLine($"namespace {namespaceName}");
                instanceGen.AppendLine("{");
            }
            
            instanceGen.AppendLine($"    /// <summary>Partial class to add Instance property to {className}.</summary>");
            instanceGen.AppendLine($"    partial class {className}");
            instanceGen.AppendLine("    {");
            instanceGen.AppendLine($"        /// <summary>Singleton instance of {className}.</summary>");
            instanceGen.AppendLine($"        public static {className} Instance {{ get; }} = new {className}();");
            instanceGen.AppendLine("    }");
            
            if (!string.IsNullOrEmpty(namespaceName))
            {
                instanceGen.AppendLine("}");
            }
            
            context.AddSource($"{sym.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted)).Replace(".", "_")}.Instance.g.cs", instanceGen.ToString());

            // Add to loader
            loader.AppendLine($"            _ = global::{fullTypeName}.Instance;");

            IPropertySymbol[] cfgProps = sym.GetMembers().OfType<IPropertySymbol>()
                .Where(p => p.GetAttributes().Any(at => SymbolEqualityComparer.Default.Equals(at.AttributeClass, cfgAttr)))
                .ToArray();

            string cfgName = className + "Configuration";

            // Generate configuration class
            StringBuilder cfg = new StringBuilder();
            cfg.AppendLine("// <auto-generated/>");
            cfg.AppendLine($"namespace {GeneratedNamespace}");
            cfg.AppendLine("{");
            cfg.AppendLine($"    /// <summary>Configuration for the {className} modifier.</summary>");
            cfg.AppendLine("    public sealed class " + cfgName);
            cfg.AppendLine("    {");
            cfg.AppendLine("        /// <summary>Whether this modifier is enabled.</summary>");
            cfg.AppendLine("        public bool Enabled { get; set; } = false;");

            foreach (IPropertySymbol p in cfgProps)
            {
                if (p.Name == "Enabled")
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "MODCFG001",
                            "Reserved name",
                            "Enabled is generated automatically and must not be user-declared.",
                            "Modifiers",
                            DiagnosticSeverity.Error,
                            true),
                        p.Locations[0]));
                    continue;
                }

                AttributeData at = p.GetAttributes()
                    .First(x => SymbolEqualityComparer.Default.Equals(x.AttributeClass, cfgAttr));

                object def = null;
                foreach (var kv in at.NamedArguments)
                    if (kv.Key == "Default")
                        def = kv.Value.Value;

                var desc = at.NamedArguments.FirstOrDefault(x => x.Key == "Description").Value.Value;
                cfg.AppendLine($"        /// <summary>{desc}</summary>");
                cfg.AppendLine("        public " + p.Type.ToDisplayString() + " " + p.Name +
                               " { get; set; } = " + Format(def) + ";");
            }

            cfg.AppendLine("    }");
            cfg.AppendLine("}");
            context.AddSource(cfgName + ".g.cs", cfg.ToString());

            // Add property in root Configuration
            rootCfg.AppendLine("        /// <summary>Configuration for the " + className + " modifier.</summary>");
            rootCfg.AppendLine("        public " + cfgName + " " + className + " { get; set; } = new " + cfgName + "();");

            // Generate ApplyConfigurationTo / PullConfigurationFrom
            rootCfg.AppendLine("        /// <summary>Applies this configuration to the provided modifier instance.</summary>");
            rootCfg.AppendLine("        public void ApplyConfigurationTo(global::" + fullTypeName + " modifier)");
            rootCfg.AppendLine("        {");
            rootCfg.AppendLine("            var config = this." + className + ";");
            rootCfg.AppendLine("            if (config.Enabled) modifier.Enable();");
            foreach (IPropertySymbol p in cfgProps)
                rootCfg.AppendLine("            modifier." + p.Name + " = config." + p.Name + ";");
            rootCfg.AppendLine("        }");

            rootCfg.AppendLine("        /// <summary>Updates this configuration from the provided modifier instance.</summary>");
            rootCfg.AppendLine("        public void PullConfigurationFrom(global::" + fullTypeName + " modifier)");
            rootCfg.AppendLine("        {");
            rootCfg.AppendLine("            var config = this." + className + ";");
            rootCfg.AppendLine("            config.Enabled = modifier.IsEnabled;");
            foreach (IPropertySymbol p in cfgProps)
                rootCfg.AppendLine("            config." + p.Name + " = modifier." + p.Name + ";");
            rootCfg.AppendLine("        }");

            // Add to ApplyAll / PullAll with global:: qualifier
            applyAllCalls.Add($"ApplyConfigurationTo(global::{fullTypeName}.Instance);");
            pullAllCalls.Add($"PullConfigurationFrom(global::{fullTypeName}.Instance);");
        }

        // Generate descriptive ApplyAll / PullAll
        rootCfg.AppendLine("        /// <summary>Applies all modifier configurations to their respective instances.</summary>");
        rootCfg.AppendLine("        public void ApplyAllModifierConfigurations()");
        rootCfg.AppendLine("        {");
        foreach (var call in applyAllCalls)
            rootCfg.AppendLine("            " + call);
        rootCfg.AppendLine("        }");

        rootCfg.AppendLine("        /// <summary>Pulls all modifier states back into their configuration objects.</summary>");
        rootCfg.AppendLine("        public void PullAllModifierConfigurations()");
        rootCfg.AppendLine("        {");
        foreach (var call in pullAllCalls)
            rootCfg.AppendLine("            " + call);
        rootCfg.AppendLine("        }");

        loader.AppendLine("        }");
        loader.AppendLine("    }");
        loader.AppendLine("}");
        rootCfg.AppendLine("    }");
        rootCfg.AppendLine("}");

        context.AddSource("GeneratedModifierLoader.g.cs", loader.ToString());
        context.AddSource("GeneratedModifierConfigurationExtensions.g.cs", rootCfg.ToString());
    }

    static string GetNamespace(ISymbol symbol)
    {
        if (symbol.ContainingNamespace == null || symbol.ContainingNamespace.IsGlobalNamespace)
            return string.Empty;

        var parts = new List<string>();
        var ns = symbol.ContainingNamespace;
        while (ns != null && !ns.IsGlobalNamespace)
        {
            parts.Insert(0, ns.Name);
            ns = ns.ContainingNamespace;
        }
        return string.Join(".", parts);
    }

    static INamedTypeSymbol FindTypeByName(Compilation compilation, string typeName)
    {
        // Search through all types in all referenced assemblies and source
        var visitor = new TypeSearchVisitor(typeName);
        foreach (var tree in compilation.SyntaxTrees)
        {
            var semanticModel = compilation.GetSemanticModel(tree);
            visitor.Visit(tree.GetRoot(), semanticModel);
            if (visitor.FoundType != null)
                return visitor.FoundType;
        }

        // Also search in referenced assemblies
        return compilation.GetSymbolsWithName(
            name => name == typeName,
            SymbolFilter.Type)
            .OfType<INamedTypeSymbol>()
            .FirstOrDefault();
    }

    class TypeSearchVisitor
    {
        private readonly string _targetName;
        public INamedTypeSymbol FoundType { get; private set; }

        public TypeSearchVisitor(string targetName)
        {
            _targetName = targetName;
        }

        public void Visit(SyntaxNode node, SemanticModel model)
        {
            if (FoundType != null)
                return;

            if (node is ClassDeclarationSyntax cls && cls.Identifier.Text == _targetName)
            {
                FoundType = model.GetDeclaredSymbol(cls) as INamedTypeSymbol;
                return;
            }

            foreach (var child in node.ChildNodes())
            {
                Visit(child, model);
                if (FoundType != null)
                    return;
            }
        }
    }

    static bool InheritsFrom(INamedTypeSymbol t, INamedTypeSymbol b)
    {
        while (t != null)
        {
            if (SymbolEqualityComparer.Default.Equals(t, b))
                return true;
            t = t.BaseType;
        }
        return false;
    }

    static string Format(object o)
    {
        if (o == null) return "default";
        if (o is bool v2) return v2 ? "true" : "false";
        if (o is float v) return v.ToString(System.Globalization.CultureInfo.InvariantCulture) + "f";
        if (o is double v1) return v1.ToString(System.Globalization.CultureInfo.InvariantCulture);
        if (o is string) return "\"" + o.ToString() + "\"";
        return o.ToString();
    }
}