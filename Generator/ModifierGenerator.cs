using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Collections.Generic;

[Generator]
public sealed class ModifierGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Identify candidate classes: non-empty attribute lists
        var candidates = context.SyntaxProvider.CreateSyntaxProvider(
            (n, _) => n is ClassDeclarationSyntax c && c.AttributeLists.Count > 0,
            (ctx, _) => (ClassDeclarationSyntax)ctx.Node);

        // Combine compilation info with collected candidates
        var combined = context.CompilationProvider.Combine(candidates.Collect());
        context.RegisterSourceOutput(combined, Generate); // Trigger generation
    }

    static void Generate(SourceProductionContext context,
        (Compilation, ImmutableArray<ClassDeclarationSyntax>) data)
    {
        Compilation compilation = data.Item1;
        ImmutableArray<ClassDeclarationSyntax> classes = data.Item2;

        // Look up necessary types in the compilation
        INamedTypeSymbol autoAttr = compilation.GetTypeByMetadataName("AutoModifierAttribute");
        INamedTypeSymbol baseType = compilation.GetTypeByMetadataName("Modifier");
        INamedTypeSymbol cfgAttr = compilation.GetTypeByMetadataName("ConfigurableAttribute");

        if (autoAttr == null || baseType == null || cfgAttr == null)
            return; // Can't generate if any type is missing

        StringBuilder loader = new StringBuilder();
        loader.AppendLine("// <auto-generated/>");
        loader.AppendLine("/// <summary>Automatically loads all modifiers and initializes their static instances.</summary>");
        loader.AppendLine("public static class GeneratedModifierLoader");
        loader.AppendLine("{");
        loader.AppendLine("    public static void LoadAllModifiers()");
        loader.AppendLine("    {");

        StringBuilder rootCfg = new StringBuilder();
        rootCfg.AppendLine("// <auto-generated/>");
        rootCfg.AppendLine("/// <summary>Partial Configuration class generated for all modifiers.</summary>");
        rootCfg.AppendLine("public sealed partial class Configuration");
        rootCfg.AppendLine("{");

        List<string> applyAllCalls = new List<string>();
        List<string> pullAllCalls = new List<string>();

        foreach (ClassDeclarationSyntax cls in classes)
        {
            SemanticModel model = compilation.GetSemanticModel(cls.SyntaxTree);

            // Skip abstract classes or those without a valid symbol
            if (!(model.GetDeclaredSymbol(cls) is INamedTypeSymbol sym) || sym.IsAbstract)
                continue;

            // Find [AutoModifier] attribute on the class
            AttributeData a = sym.GetAttributes()
                .FirstOrDefault(x => SymbolEqualityComparer.Default.Equals(x.AttributeClass, autoAttr));
            if (a == null || !InheritsFrom(sym, baseType))
                continue; // Skip if not a modifier

            string member = a.ConstructorArguments[0].Value as string;
            if (!string.IsNullOrEmpty(member))
                loader.AppendLine("        _ = " + sym.ToDisplayString() + "." + member + ";"); // Force static initialization

            // Collect configurable properties marked with [Configurable]
            IPropertySymbol[] cfgProps = sym.GetMembers().OfType<IPropertySymbol>()
                .Where(p => p.GetAttributes().Any(at => SymbolEqualityComparer.Default.Equals(at.AttributeClass, cfgAttr)))
                .ToArray();

            string cfgName = sym.Name + "Configuration";

            // Generate individual modifier configuration class
            StringBuilder cfg = new StringBuilder();
            cfg.AppendLine("// <auto-generated/>");
            cfg.AppendLine($"/// <summary>Configuration for the {sym.Name} modifier.</summary>");
            cfg.AppendLine("public sealed class " + cfgName);
            cfg.AppendLine("{");
            cfg.AppendLine("    /// <summary>Whether this modifier is enabled.</summary>");
            cfg.AppendLine("    public bool Enabled { get; set; } = false;");

            foreach (IPropertySymbol p in cfgProps)
            {
                if (p.Name == "Enabled")
                {
                    // Error if user tries to declare 'Enabled' manually
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "MODCFG001",
                            "Reserved name",
                            "Enabled is generated automatically and must not be user-declared.",
                            "Modifiers",
                            DiagnosticSeverity.Error,
                            true),
                        p.Locations[0]));
                    continue;
                }

                AttributeData at = p.GetAttributes()
                    .First(x => SymbolEqualityComparer.Default.Equals(x.AttributeClass, cfgAttr));

                object def = null;
                foreach (var kv in at.NamedArguments)
                    if (kv.Key == "Default")
                        def = kv.Value.Value; // Pull default value from attribute

                var desc = at.NamedArguments.FirstOrDefault(x => x.Key == "Description").Value.Value;
                cfg.AppendLine($"    /// <summary>{desc}</summary>");
                cfg.AppendLine("    public " + p.Type.ToDisplayString() + " " + p.Name +
                               " { get; set; } = " + Format(def) + ";");
            }

            cfg.AppendLine("}");
            context.AddSource(cfgName + ".g.cs", cfg.ToString());

            // Add this modifier to root configuration
            rootCfg.AppendLine("    /// <summary>Configuration for the " + sym.Name + " modifier.</summary>");
            rootCfg.AppendLine("    public " + cfgName + " " + sym.Name + " { get; set; } = new " + cfgName + "();");

            // Generate helper methods to apply and pull configurations for each modifier
            rootCfg.AppendLine("    public void ApplyConfigurationTo(" + sym.Name + " modifier)");
            rootCfg.AppendLine("    {");
            rootCfg.AppendLine("        var config = this." + sym.Name + ";");
            rootCfg.AppendLine("        if (config.Enabled) modifier.Enable();");
            foreach (IPropertySymbol p in cfgProps)
                rootCfg.AppendLine("        modifier." + p.Name + " = config." + p.Name + ";");
            rootCfg.AppendLine("    }");

            rootCfg.AppendLine("    public void PullConfigurationFrom(" + sym.Name + " modifier)");
            rootCfg.AppendLine("    {");
            rootCfg.AppendLine("        var config = this." + sym.Name + ";");
            rootCfg.AppendLine("        config.Enabled = modifier.IsEnabled;");
            foreach (IPropertySymbol p in cfgProps)
                rootCfg.AppendLine("        config." + p.Name + " = modifier." + p.Name + ";");
            rootCfg.AppendLine("    }");

            // Keep track for batch apply/pull
            applyAllCalls.Add($"ApplyConfigurationTo(global::{sym.Name}.{member});");
            pullAllCalls.Add($"PullConfigurationFrom(global::{sym.Name}.{member});");
        }

        // Generate batch apply/pull methods
        rootCfg.AppendLine("    public void ApplyAllModifierConfigurations()");
        rootCfg.AppendLine("    {");
        foreach (var call in applyAllCalls)
            rootCfg.AppendLine("        " + call);
        rootCfg.AppendLine("    }");

        rootCfg.AppendLine("    public void PullAllModifierConfigurations()");
        rootCfg.AppendLine("    {");
        foreach (var call in pullAllCalls)
            rootCfg.AppendLine("        " + call);
        rootCfg.AppendLine("    }");

        loader.AppendLine("    }");
        loader.AppendLine("}");
        rootCfg.AppendLine("}");

        // Add generated sources
        context.AddSource("GeneratedModifierLoader.g.cs", loader.ToString());
        context.AddSource("GeneratedModifierConfigurationExtensions.g.cs", rootCfg.ToString());
    }

    // Helper: check inheritance chain
    static bool InheritsFrom(INamedTypeSymbol t, INamedTypeSymbol b)
    {
        while (t != null)
        {
            if (SymbolEqualityComparer.Default.Equals(t, b))
                return true;
            t = t.BaseType;
        }
        return false;
    }

    // Helper: format default values in source code
    static string Format(object o)
    {
        if (o == null) return "default";
        if (o is bool v2) return v2 ? "true" : "false";
        if (o is float v) return v.ToString(System.Globalization.CultureInfo.InvariantCulture) + "f";
        if (o is double v1) return v1.ToString(System.Globalization.CultureInfo.InvariantCulture);
        if (o is string) return "\"" + o.ToString() + "\"";
        return o.ToString();
    }
}
